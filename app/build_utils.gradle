/*
 * Copyright В© 2014 TIBCO Software, Inc. All rights reserved.
 *  http://community.jaspersoft.com/project/jaspermobile-android
 *
 *  Unless you have purchased a commercial license agreement from Jaspersoft,
 *  the following license terms apply:
 *
 *  This program is part of Jaspersoft Mobile for Android.
 *
 *  Jaspersoft Mobile is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Jaspersoft Mobile is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with Jaspersoft Mobile for Android. If not, see
 *  <http://www.gnu.org/licenses/lgpl>.
 */

/*
    In order to run build with and increment use flag -PincrementBuild=true
    In order to have timestamp in build name use flag -PneedTimeStamp=true
    For e.g. gradlew assembleQaRelease -PincrementBuild=true -PneedTimeStamp=true

    P.S. gradlew assembleQaRelease -PneedTimeStamp=true
         will increment build event without appropriate flag
 */

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'org.ajoberstar:gradle-git:1.1.0'
    }
}

import java.text.NumberFormat
import org.ajoberstar.grgit.*

ext {
    versionFile = new File(project.rootDir, 'version.properties')

    calculateVersionName = { variant ->
        def version = readVersion()
        def versionName = "${version['major']}.${version['minor']}.${version['patch']}"

        if (variant != null) {
            def flavorName = variant.getFlavorName()
            def dev = flavorName.equals("dev")
            def qa = flavorName.equals("qa")

            if (qa) {
                def repo = Grgit.open(project.rootDir)
                def branch = repo.branch.getCurrent().getName()
                def sanitizedBranch = branch.replaceAll("/", "_")

                def notMaster = !sanitizedBranch.equals('master')
                def notDevelop = !sanitizedBranch.equals('develop')

                if (notMaster) {
                    if (notDevelop && sanitizedBranch.length() > 0) {
                        versionName += "-${sanitizedBranch}-${version['revision']}"
                    }
                }
            }

            if (dev) {
                versionName += "-SNAPSHOT"
            }

            def needTimeStamp = false
            if (project.hasProperty("needTimeStamp")) {
                needTimeStamp = project.needTimeStamp
            }
            if (needTimeStamp) {
                TimeZone.setDefault(TimeZone.getTimeZone('UTC'))
                def now = new Date().format("yyyy_MM_dd-HH_mm_ss")
                versionName += '-' + now
            }
        }
        return versionName
    }

    /**
     * Pattern for versionCode:
     * android:versionCode="vvxxyyzz"
     * where:
     * vv - min android sdk version
     * xx - major version number
     * yy - minor version number
     * zz - revision number
     */
    calculateVersionCode = { variant ->
        def versionCode = ""
        def version = readVersion()
        def major = version['major'] as int // 1..?
        def minor = version['minor'] as int // 0..99
        def build = version['patch'] as int // 0..999

        def format = NumberFormat.getInstance()
        format.setMinimumIntegerDigits(2)

        if (variant != null) {
            def flavor = variant.mergedFlavor
            def minSdk = flavor.minSdkVersion.getApiLevel()
            versionCode += minSdk
        }

        versionCode += format.format(major)
        versionCode += format.format(minor)
        versionCode += format.format(build)
        return Integer.valueOf(versionCode)
    }
}

Properties readVersion() {
    def version = new Properties()
    def stream
    try {
        stream = new FileInputStream(versionFile)
        version.load(stream)
    } catch (java.io.FileNotFoundException ignore) {
    } finally {
        if (stream != null) stream.close()
    }
    // safety defaults in case file is missing
    if (!version['major']) version['major'] = "1"
    if (!version['minor']) version['minor'] = "0"
    if (!version['patch']) version['patch'] = "0"
    if (!version['revision']) version['revision'] = "0"
    return version
}

task incrementVersion {
    description "Increments build counter in ${versionFile}"
    doFirst {
        incrementRevisionNumber()
    }
}

void incrementRevisionNumber() {
    def version = readVersion()

    def build = version['revision'] as int
    build++
    version['revision'] = build.toString()

    def stream = new FileOutputStream(versionFile)
    try {
        version.store(stream, null)
    } finally {
        stream.close()
    }
}

if (plugins.hasPlugin('android') || plugins.hasPlugin('android-library')) {
    android {
        defaultConfig {
            versionName = calculateVersionName(null)
            versionCode = calculateVersionCode(null)
        }

        def shouldIncrementBuild = false
        if (project.hasProperty("incrementBuild")) {
            shouldIncrementBuild = project.incrementBuild
        }
        if (project.hasProperty("needTimeStamp")) {
            shouldIncrementBuild = true
        }

        if (shouldIncrementBuild) {
            afterEvaluate {
                def renameApk = { targetVariant ->
                    def buildType = targetVariant.buildType
                    def mergedFlavor = targetVariant.mergedFlavor
                    targetVariant.outputs.each { output ->
                        def versionSuffix = buildType.versionNameSuffix ? buildType.versionNameSuffix : ""
                        def apkName = versionSuffix + mergedFlavor.versionName

                        def file = output.packageApplication.outputFile
                        def fileName = file.name.replace(".apk", "-" + apkName + ".apk")

                        if (output.zipAlign) {
                            output.zipAlign.outputFile = new File(file.parentFile, fileName.replace("-unaligned", ""))
                        }
                    }
                }
                def autoIncrementVariant = { variant ->
                    variant.preBuild.dependsOn incrementVersion
                    incrementVersion.doLast {
                        variant.mergedFlavor.versionName = calculateVersionName(variant)
                        variant.mergedFlavor.versionCode = calculateVersionCode(variant)
                        renameApk(variant)
                    }
                }

                if (plugins.hasPlugin('android')) {
                    applicationVariants.all { variant ->
                        autoIncrementVariant(variant)
                    }
                }

                if (plugins.hasPlugin('android-library')) {
                    libraryVariants.all { variant ->
                        autoIncrementVariant(variant)
                    }
                }
            }
        }
    }
}