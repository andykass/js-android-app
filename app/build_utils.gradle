/*
 * Copyright Â© 2015 TIBCO Software, Inc. All rights reserved.
 * http://community.jaspersoft.com/project/jaspermobile-android
 *
 * Unless you have purchased a commercial license agreement from Jaspersoft,
 * the following license terms apply:
 *
 * This program is part of TIBCO Jaspersoft Mobile for Android.
 *
 * TIBCO Jaspersoft Mobile is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * TIBCO Jaspersoft Mobile is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with TIBCO Jaspersoft Mobile for Android. If not, see
 * <http://www.gnu.org/licenses/lgpl>.
 */

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'org.ajoberstar:gradle-git:1.1.0'
    }
}

import org.ajoberstar.grgit.*

import java.text.NumberFormat

ext {
    versionFile = new File(project.rootDir, 'version.properties')
    currentBranch = getCurrentBranch()
    baseAppName = "jaspermobile"
}

android {
    afterEvaluate {
        def defaultVersionName = getDefaultVersionName()
        def revision = getRevisionNumber(defaultVersionName)

        if (currentBranchIsProd()) {
            revision++
            updateVersionNumberInFile(defaultVersionName, revision)
        }

        project.ext.set("baseVersion", generateBaseVersionName(defaultVersionName))
        project.ext.set("fullVersion", generateFullVersionName(project.ext.baseVersion, revision))
        def versionCode = generateVersionCodeValue(defaultVersionName, revision) as int

        //update values for different build tasks
        applicationVariants.all { variant ->
            variant.mergedFlavor.versionCode = versionCode
            updateBuildValues(variant)
        }
    }
}
//---------------------------------------------------------------------
// Helper methods
//---------------------------------------------------------------------
String getCurrentBranch() {
    def repo = Grgit.open(project.rootDir)
    def branch = repo.branch.getCurrent().getName()
    return branch.replaceAll("/", "_")
}

boolean currentBranchIsProd() {
    return (currentBranch.equalsIgnoreCase("develop") ||
            currentBranch.equalsIgnoreCase("master") ||
            currentBranch.equalsIgnoreCase("hotfix")) ||
            currentBranch.contains("release")
    ;
}

Properties getDefaultVersionName() {
    def versionName = new Properties()
    def appVersionName = android.defaultConfig.versionName as String

    if (appVersionName ==~ /(\d).(\d{1,2}).(\d{1,2})/) {
        def versions = appVersionName.tokenize('.')

        versionName['major'] = versions[0]
        versionName['minor'] = versions[1]
        versionName['patch'] = versions[2]

        return versionName as Properties
    } else throw new InvalidPropertiesFormatException("Version name does not match pattern available pattern!")
}

String generateBaseVersionName(defaultVersionName) {
    def format = NumberFormat.getInstance()
    def major = defaultVersionName['major'] as int // 1..?
    def minor = defaultVersionName['minor'] as int // 0..99
    def patch = defaultVersionName['patch'] as int // 0..99

    format.setMinimumIntegerDigits(1)
    minor = format.format(minor)
    patch = format.format(patch)

    return "${major}.${minor}.${patch}"
}

String generateFullVersionName(baseVersionName, revisionNumber) {
    def format = NumberFormat.getInstance()
    format.setMinimumIntegerDigits(3)
    revisionNumber = format.format(revisionNumber)

    return "${baseVersionName}.${revisionNumber}"
}

Properties getVersionNameFromFile() {
    def version = new Properties()
    def stream

    try {
        stream = new FileInputStream(versionFile)
        version.load(stream)
    } catch (FileNotFoundException ignore) {
        return null
    } finally {
        if (stream != null) stream.close()
    }

    // safety defaults in case file is missing
    if (!version['major'] || !version['minor'] || !version['patch'] || !version['revision']) return null

    return version
}

int getRevisionNumber(defaultVersionName) {
    def revision = 0 as int //0..999
    def previousVersionName = getVersionNameFromFile()

    if (previousVersionName != null)
        if (previousVersionName['major'] as int != defaultVersionName['major'] ||
                previousVersionName['minor'] as int != defaultVersionName['minor'] ||
                previousVersionName['patch'] as int != defaultVersionName['patch'])
            revision = previousVersionName['revision'] as int

    return revision
}

/**
 * Pattern for versionCode:
 * android:versionCode="xxyyzzvvv"
 * where:
 * xx - major version number
 * yy - minor version number
 * zz - patch version
 * vvv - revision number
 */
int generateVersionCodeValue(defaultVersionName, revision) {
    def versionCode = ""

    def format = NumberFormat.getInstance()
    format.setMinimumIntegerDigits(2)

    versionCode += format.format(defaultVersionName.major as int)
    versionCode += format.format(defaultVersionName.minor as int)
    versionCode += format.format(defaultVersionName.patch as int)

    format.setMinimumIntegerDigits(3)
    versionCode += format.format(revision)

    return Integer.valueOf(versionCode)
}

void updateBuildValues(flavor) {
    TimeZone.setDefault(TimeZone.getTimeZone('UTC'))

    def productFlavorName = flavor.name
    def branchNamePart = currentBranchIsProd() ? "" : "-${currentBranch}"
    def timeNow = new Date().format("yyyy_MM_dd-HH_mm")
    def snapshot = "SNAPSHOT"

    def versionName = baseVersion
    def apkName = "${baseAppName}-${baseVersion}"

    if (productFlavorName.equalsIgnoreCase("productionRelease")) {
        versionName = "${baseVersion}${branchNamePart}"
        apkName = "${baseAppName}-${fullVersion}${branchNamePart}-${timeNow}"
    } else if (productFlavorName.equalsIgnoreCase("devRelease")) {
        versionName = "${fullVersion}${branchNamePart}"
        apkName = "${baseAppName}-${baseVersion}${branchNamePart}-${timeNow}"
    } else if (productFlavorName.equalsIgnoreCase("devDebug")) {
        versionName = "${baseVersion}${branchNamePart}-${snapshot}"
        apkName = "${baseAppName}-${baseVersion}${branchNamePart}-${snapshot}"
    }
    flavor.mergedFlavor.versionName = versionName
    renameApk(flavor, apkName)
}

void updateVersionNumberInFile(defaultVersionName, revision) {
    def appVersion = new Properties()
    appVersion['major'] = defaultVersionName['major']
    appVersion['minor'] = defaultVersionName['minor']
    appVersion['patch'] = defaultVersionName['patch']
    appVersion['revision'] = revision.toString()

    def stream = new FileOutputStream(versionFile)
    try {
        appVersion.store(stream, null)
    } finally {
        if (stream != null) stream.close()
    }
}

void renameApk(flavor, apkName) {
    def outputs = flavor.outputs

    outputs.each { output ->
        if (flavor.buildType.zipAlignEnabled) {
            // normal APK
            output.outputFile = new File(output.outputFile.parent, "${apkName}.apk")
        }
        // 'unaligned' APK
        def unalignedApkName = "${baseAppName}-${baseVersion}-unaligned.apk"
        output.packageApplication.outputFile = new File(output.packageApplication.outputFile.parent, unalignedApkName)
    }
}