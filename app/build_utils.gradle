/*
 * Copyright Â© 2015 TIBCO Software, Inc. All rights reserved.
 * http://community.jaspersoft.com/project/jaspermobile-android
 *
 * Unless you have purchased a commercial license agreement from Jaspersoft,
 * the following license terms apply:
 *
 * This program is part of TIBCO Jaspersoft Mobile for Android.
 *
 * TIBCO Jaspersoft Mobile is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * TIBCO Jaspersoft Mobile is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with TIBCO Jaspersoft Mobile for Android. If not, see
 * <http://www.gnu.org/licenses/lgpl>.
 */

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'org.ajoberstar:gradle-git:1.1.0'
    }
}

import org.ajoberstar.grgit.*

import java.text.NumberFormat

ext {
    versionFile = new File(project.rootDir, 'version.properties')
    currentBranch = getCurrentBranch()

    genVersionCode = {
        return _genVersionCode()
    }

    genVersionName = {
        return _genVersionName()
    }
}

//---------------------------------------------------------------------
// Helper methods
//---------------------------------------------------------------------

/**
 * Return version code of app version. Used for Google Play build identification.
 * Pattern for version code: "xxyyzzvvv"
 * where:
 * xx - major version number
 * yy - minor version number
 * zz - patch version
 * vvv - revision number
 */
def _genVersionCode() {
    Properties appVersion = getVersionFromFile()

    String versionCode = ""

    def format = NumberFormat.getInstance()
    format.setMinimumIntegerDigits(2)

    versionCode += format.format(appVersion.major as int)
    versionCode += format.format(appVersion.minor as int)
    versionCode += format.format(appVersion.patch as int)

    format.setMinimumIntegerDigits(3)
    versionCode += format.format(appVersion['revision'] as int)

    return Integer.valueOf(versionCode)
}

/**
 * Return text representation of app version.
 * Pattern for version number: "x.y.z.vvv"
 * where:
 * x - major version number
 * y - minor version number
 * z - patch version
 * vvv - revision number
 * branchName - current branch except [develop, master, hotfix, release]
 * @param appVersion app version bundle
 * @param revisionNumber current revision number
 * @return text representation of app version
 */
def _genVersionName() {
    Properties appVersion = getVersionFromFile()

    def format = NumberFormat.getInstance()
    format.setMinimumIntegerDigits(1)

    def major = format.format(appVersion['major'] as int) // 1..?
    def minor = format.format(appVersion['minor'] as int) // 0..99
    def patch = format.format(appVersion['patch'] as int) // 0..99

    format.setMinimumIntegerDigits(3)
    def revision = format.format(appVersion['revision'] as int)

    String branchName = currentBranchIsProd() ? "" : "-${currentBranch}"

    return "jaspermobile-${major}.${minor}.${patch}.${revision}${branchName}"
}

/**
 * Return current branch name
 * @return current branch
 */
String getCurrentBranch() {
    def repo = Grgit.open(project.rootDir)
    String branch = repo.branch.getCurrent().getName()
    return branch.replaceAll("/", "_")
}

/**
 * Check if current branch is "develop", "master", "release" or "hotfix".
 * @return if current branch is one of production branches
 */
boolean currentBranchIsProd() {
    return (currentBranch.equalsIgnoreCase("develop") ||
            currentBranch.equalsIgnoreCase("master") ||
            currentBranch.equalsIgnoreCase("hotfix")) ||
            currentBranch.equalsIgnoreCase("release");
}

/**
 * Return app version bundle that was saved in file
 */
Properties getVersionFromFile() {
    Properties version = new Properties()
    def stream

    try {
        stream = new FileInputStream(versionFile)
        version.load(stream)
    } catch (FileNotFoundException ignore) {
        return null
    } finally {
        if (stream != null) stream.close()
    }

    // safety defaults in case file is missing
    if (!version['major'] || !version['minor'] || !version['patch'] || !version['revision']) return null

    return version
}